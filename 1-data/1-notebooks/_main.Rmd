---
always_allow_html: yes
df_print: tibble
output:
  html_notebook:
    code_folding: hide
  html_document: default
  pdf_document:
    keep_tex: yes
---

```{r hra-tr-setup, echo = FALSE, warning=FALSE,message=FALSE,comment=FALSE}
library(plyr)
library(knitr)
library(rprojroot)
library(tidyverse)
library(rgdal)
library(sp)
library(rgeos)
library(miscgis)
library(tigris)
library(leaflet)
library(ggthemes)
library(magrittr)
library(stringr)
library(downloader)
library(webshot)
library(htmltools)
library(gplots)
library(ggmap)
library(shiny)
library(htmlwidgets)
library(readxl)
library(acs)
library(RColorBrewer)
root <- rprojroot::is_rstudio_project
root_file <- root$make_fix_file()
opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, comment=FALSE)
```

### Introduction
Resolving geographic units that do not neatly coincide is a common problem in spatial data analysis. The method outline here attempts to conflate King County Health Reporting Areas (HRAs) to US Census tracts. In the cases where a given tract is entirely within an HRA, that tract receives the HRA's unique identifier (HRA_ID). On the other hand, in cases where a given tract overlaps multiple HRAs, block-level census data is used to determine which HRA ID to assign to the tract. 

### Census Block Counts
This method provides three alternatives of block-level counts that can be used:

```{r hra-tr-vartable, fig.cap='Block-level counts'}
tibble('Count Type' = c('Population',
                        'Housing Units',
                        'Population in Housing Units'),
       'Variable ID' = c('`POP`',
                         '`HU`',
                         '`HUPOP`'),
       'Source' = c('Table P1, U.S. Census Bureau, 2010 Census',
                    'Table H1, U.S. Census Bureau, 2010 Census',
                    'Table H10, U.S. Census Bureau, 2010 Census')) %>% 
        kable()
```

  
```{r hra-tr-blks}

if(!file.exists(root_file('1-data/4-interim/kc-blk-sp.gpkg'))){
        pop <- read_csv(root_file('1-data/3-external/manual/wa-blk/DEC_10_SF1_P1/DEC_10_SF1_P1_with_ann.csv'), 
                        col_types = cols(Id2 = col_character()), 
                        skip = 1) %>% 
                mutate(GEO_ID_BLK = Id2,
                       GEOID_TR = substr(Id2,start = 1,stop = 11),
                       POP = Total) %>% 
                select(GEO_ID_BLK,GEOID_TR,POP)
        
        hu <- read_csv(root_file('1-data/3-external/manual/wa-blk/DEC_10_SF1_H1/DEC_10_SF1_H1_with_ann.csv'), 
                       col_types = cols(Id2 = col_character()), 
                       skip = 1) %>% 
                mutate(GEO_ID_BLK = Id2,
                       HU = Total) %>% 
                select(GEO_ID_BLK,HU)
        
        pophu <- read_csv(root_file('1-data/3-external/manual/wa-blk/DEC_10_SF1_H10/DEC_10_SF1_H10_with_ann.csv'), 
                          col_types = cols(Id2 = col_character()), 
                          skip = 1) %>% 
                mutate(GEO_ID_BLK = Id2,
                       POPHU = Total) %>% 
                select(GEO_ID_BLK,POPHU)
        
        cnts <- left_join(pop,hu,by = 'GEO_ID_BLK') %>% 
                left_join(pophu,by = 'GEO_ID_BLK')
        
        # Source for KC Blocks spatial data
        if(!file.exists(root_file('1-data/3-external/wa-blk/blocks10/blocks10.shp'))){
                url <- 'ftp://ftp.kingcounty.gov/gis-web/web/GISData/blocks10_SHP.zip' # direct URL to the file download
                
                temp <- tempfile() # create a temporary file to hold the compressed download
                
                download(url, dest = temp, mode='wb') # download the file
                
                unzip (temp, exdir = root_file('1-data/3-external/wa-blk')) # extract the file to the project folder
        }
        
        kc_blk <- readOGR(dsn = root_file('1-data/3-external/wa-blk/blocks10/'),
                          layer = 'blocks10',
                          verbose = FALSE,
                          stringsAsFactors = FALSE)
        
        kc_blk@data %<>% left_join(cnts, by = 'GEO_ID_BLK') %>% 
                select(GEOID_BLK = GEO_ID_BLK,
                       GEOID_TR:POPHU)
        
        kc_blk %>% writeOGR(dsn = root_file('1-data/4-interim/kc-blk-sp.gpkg'),
                            layer = 'kc_blk_sp',
                            driver = 'GPKG',
                            overwrite_layer = TRUE,verbose = FALSE)
}

kc_blk_sp <- readOGR(dsn = root_file('1-data/4-interim/kc-blk-sp.gpkg'),
                            layer = 'kc_blk_sp',
                  stringsAsFactors = FALSE,
                  verbose = FALSE)



```


### The Algorithm 
The following actions are performed in this method:

  1. Centroids of the census block polygons are calculated (`class = SpatialPointsDataFrame`)
  2. HRA IDs are passed to the block centroid using a spatial overlay method (`sp::over()`)
  3. Blocks are aggregated into tracts and the count variables (`POP`,`HU`,`POPHU`) are summed
  4. For each count variable, the HRA ID with the highest sum is assigned to each tract
  
```{r hra-assign}

# Pass HRA IDs to the block centroids
hra <- readOGR(dsn = root_file('1-data/3-external/manual/HRA_2010Block_Clip/'),layer = 'HRA_2010Block_Clip',
               verbose = FALSE,stringsAsFactors = FALSE)

kc_blk_cnt_sp <- SpatialPointsDataFrame(coords = rgeos::gCentroid(kc_blk_sp,byid = TRUE),
                               data = as.data.frame(kc_blk_sp@data),
                               match.ID = FALSE)

kc_blk_cnt_sp$HRA_ID <- sp::over(kc_blk_cnt_sp,hra[,'HRA2010v2_']) %>% unlist

kc_blk_cnt_sp@data %<>% mutate(HRA_ID = ifelse(is.na(HRA_ID),'None',HRA_ID))


# Assign HRAs to tracts
 
if(!file.exists(root_file('1-data/4-interim/kc-hra-tr-sp.gpkg'))){
        if(!file.exists(root_file('1-data/3-external/kc-tr/tracts10_shore/tracts10_shore.shp'))){
                
                url <- 'ftp://ftp.kingcounty.gov/gis-web/web/GISData/tracts10_shore_SHP.zip' # direct URL to the file download
                
                temp <- tempfile() # create a temporary file to hold the compressed download
                
                download(url, dest = temp, mode='wb') # download the file
                
                unzip (temp, exdir = root_file('1-data/3-external/kc-tr')) # extract the file to the project folder
                
                
        }
         
        kc_tr_sp <- readOGR(dsn = root_file('1-data/3-external/kc-tr/tracts10_shore/'),
                            layer = 'tracts10_shore',
                            verbose = FALSE,
                            stringsAsFactors = FALSE)
        kc_tr_sp@data %<>% select(GEOID_TR = GEO_ID_TRT)
        
        first_notNA <- function(x){first(x[!is.na(x)])}
        
        tr_hra_ids <- 
                kc_blk_cnt_sp@data %>% 
                as.data.frame() %>% 
                gather('VAR','COUNT',POP:POPHU) %>% 
                group_by(GEOID_TR,VAR,HRA_ID) %>% 
                summarise(SUM = sum(COUNT)) %>% 
                arrange(desc(SUM)) %>% 
                slice(1) %>% 
                spread(VAR,HRA_ID) %>% 
                mutate(HU_CNT = ifelse(!is.na(HU),SUM,NA_integer_),
                       POP_CNT = ifelse(!is.na(POP),SUM,NA_integer_),
                       POPHU_CNT = ifelse(!is.na(POPHU),SUM,NA_integer_)) %>% 
                select(-SUM) %>% 
                group_by(GEOID_TR) %>% 
                summarise_all(funs(first_notNA)) %>% 
                ungroup() %>% 
                select(GEOID_TR,
                       POP = POP_CNT,
                       HU = HU_CNT,
                       POPHU = POPHU_CNT,
                       HRA_POP = POP,
                       HRA_HU = HU,
                       HRA_POPHU = POPHU)
        
        tr_hra_ids2 <- 
                tr_hra_ids %>% 
                select(GEOID_TR,matches('HRA')) %>% 
                gather("VAR","HRA",matches('HRA')) %>%  
                group_by(GEOID_TR) %>% 
                summarise(ALLEQ = length(unique(HRA))==1) %>%
                left_join(tr_hra_ids,.,by = 'GEOID_TR') 
        
        # Get the percentage for each count variable
        
        pop_tr <- 
                read_csv(root_file("1-data/3-external/manual/kc-tr/DEC_10_SF1_P1/DEC_10_SF1_P1_with_ann.csv"), 
                         col_types = cols(GEO.id2 = col_character(), 
                                          Geography = col_skip(), 
                                          Id = col_skip(), 
                                          Id2 = col_character()), 
                         skip = 1) %>% 
                select(GEOID_TR = Id2,
                       POP_TR = Total)
        
        hu_tr <- 
                read_csv(root_file('1-data/3-external/manual/kc-tr/DEC_10_SF1_H1/DEC_10_SF1_H1_with_ann.csv'), 
                         col_types = cols(GEO.id2 = col_character(), 
                                          Geography = col_skip(), 
                                          Id = col_skip(), 
                                          Id2 = col_character()), 
                         skip = 1)%>% 
                select(GEOID_TR = Id2,
                       HU_TR = Total)
        
        pophu_tr <- 
                read_csv(root_file('1-data/3-external/manual/kc-tr/DEC_10_SF1_H10/DEC_10_SF1_H10_with_ann.csv'), 
                         col_types = cols(GEO.id2 = col_character(), 
                                          Geography = col_skip(), 
                                          Id = col_skip(), 
                                          Id2 = col_character()), 
                         skip = 1) %>% 
                select(GEOID_TR = Id2,
                       POPHU_TR = Total)
        
        kc_tr_sp@data %<>%
                left_join(.,tr_hra_ids2,by = 'GEOID_TR') %>% 
                left_join(.,pop_tr,by = 'GEOID_TR') %>% 
                left_join(.,hu_tr,by = 'GEOID_TR') %>% 
                left_join(.,pophu_tr,by = 'GEOID_TR') %>% 
                mutate(POP_PCT = round_any(POP/POP_TR,accuracy = .01),
                       HU_PCT = round_any(HU/HU_TR,accuracy = .01),
                       POPHU_PCT = round_any(POPHU/POPHU_TR,accuracy = .01)) %>% 
                select(GEOID_TR,
                       POP,POP_PCT,
                       HU, HU_PCT,
                       POPHU, POPHU_PCT,everything())
        
        kc_tr_sp %>% 
                writeOGR(dsn = root_file('1-data/4-interim/kc-hra-tr-sp.gpkg'),
                         layer = 'kc_hra_tr_sp',
                         driver = 'GPKG',
                         verbose = FALSE,
                         overwrite_layer = TRUE)
        
}

kc_hra_tr_sp <- 
        readOGR(dsn = root_file('1-data/4-interim/kc-hra-tr-sp.gpkg'),
                layer = 'kc_hra_tr_sp',
                verbose = FALSE) %>% 
        spTransform(crs_proj)

```

After running the assignment algorithm, it is clear that the `POP` and `POPHU` variables result in the same HRA assignments. `HU` differs from the other two variables in three of the tracts:

```{r hra-assign-results, fig.cap='Difference between the methods'}

kc_hra_tr_sp@data %>% 
        mutate(ALLEQ = as.logical(ALLEQ)) %>% 
        filter(ALLEQ == FALSE) %>% 
        select(GEOID_TR,HRA_POP,HRA_POPHU,HRA_HU) %>% 
        kable(caption = 'Difference between the methods')

```


### Maps


```{r hra-make-maps}

mypal <- RColorBrewer::brewer.pal(8,name = 'Set2')[-8]

shuffled_hra_pop <- forcats::fct_shuffle(kc_hra_tr_sp$HRA_POP) %>% factor(ordered = T)
shuffled_hra_hu <- forcats::fct_shuffle(kc_hra_tr_sp$HRA_HU) %>% factor(ordered = T)
shuffled_hra_pophu <- forcats::fct_shuffle(kc_hra_tr_sp$HRA_POPHU) %>% factor(ordered = T)

pal_pop <- colorFactor(palette = mypal,domain = shuffled_hra_pop)
pal_hu <- colorFactor(palette = mypal,domain = shuffled_hra_hu)
pal_pophu <- colorFactor(palette = mypal,domain = shuffled_hra_pophu)

hra %<>% spTransform(crs_proj)

show_hra_tr_pop <- function(){
        myLfltGrey(bumpLabels = FALSE,hideControls = FALSE) %>%
        addProviderTiles(providers$CartoDB) %>% 
        addPolygons(data = kc_hra_tr_sp,
                    smoothFactor = 0,
                    weight = 1,
                    color = col2hex("white"),
                    opacity = .85,
                    fillColor = ~pal_pop(shuffled_hra_pop),
                    fillOpacity = .5,
                    group = 'HRA Tract by Pop.',
                    popup = ~paste0(kc_hra_tr_sp$GEOID_TR)) %>% 
        addPolygons(data = hra,
                    smoothFactor = 0,
                    fillOpacity = 0,
                    weight = 2,
                    color = ~pal_pop(factor(hra$HRA2010v2_,levels = levels(shuffled_hra_pop),ordered = TRUE)),
                    opacity = 1,
                    group = 'HRAs',
                    popup = ~paste0(hra$HRA2010v2_)) %>% 
        addLayersControl(overlayGroups = c('HRA Tract by Pop.',
                                           'HRAs'),
                         position = 'topright',options = layersControlOptions(FALSE))
}

show_hra_tr_hu <- function(){
        myLfltGrey(bumpLabels = FALSE,hideControls = FALSE) %>%
        addProviderTiles(providers$CartoDB) %>% 
        addPolygons(data = kc_hra_tr_sp,
                    smoothFactor = 0,
                    weight = 1,
                    color = col2hex("white"),
                    opacity = .85,
                    fillColor = ~pal_hu(shuffled_hra_hu),
                    fillOpacity = .5,
                    group = 'HRA Tract by HU.',
                    popup = ~paste0(kc_hra_tr_sp$GEOID_TR)) %>% 
        addPolygons(data = hra,
                    smoothFactor = 0,
                    fillOpacity = 0,
                    weight = 2,
                    color = ~pal_hu(factor(hra$HRA2010v2_,levels = levels(shuffled_hra_hu),ordered = TRUE)),
                    opacity = 1,
                    group = 'HRAs',
                    popup = ~paste0(hra$HRA2010v2_)) %>% 
        addLayersControl(overlayGroups = c('HRA Tract by HU.',
                                           'HRAs'),
                         position = 'topright',options = layersControlOptions(FALSE))
}

show_hra_tr_pophu <- function(){
        myLfltGrey(bumpLabels = FALSE,hideControls = FALSE) %>%
        addProviderTiles(providers$CartoDB) %>% 
        addPolygons(data = kc_hra_tr_sp,
                    smoothFactor = 0,
                    weight = 1,
                    color = col2hex("white"),
                    opacity = .85,
                    fillColor = ~pal_pophu(shuffled_hra_pophu),
                    fillOpacity = .5,
                    group = 'HRA Tract by Pop. in HU',
                    popup = ~paste0(kc_hra_tr_sp$GEOID_TR)) %>% 
        addPolygons(data = hra,
                    smoothFactor = 0,
                    fillOpacity = 0,
                    weight = 2,
                    color = ~pal_pophu(factor(hra$HRA2010v2_,levels = levels(shuffled_hra_pophu),ordered = TRUE)),
                    opacity = 1,
                    group = 'HRAs',
                    popup = ~paste0(hra$HRA2010v2_)) %>% 
        addLayersControl(overlayGroups = c('HRA Tract by Pop. in HU',
                                           'HRAs'),
                         position = 'topright',options = layersControlOptions(FALSE))
}

# Save the maps as HTML documents

if(!file.exists(root_file('3-communication/others/html/hra-tracts-pop.html'))){
        show_hra_tr_pop() %>% 
        saveWidget(file = root_file('3-communication/others/html/hra-tracts-pop.html'),
                           selfcontained = FALSE,
                           libdir = root_file('3-communication/others/html/html_support_files'))
}

if(!file.exists(root_file('3-communication/others/html/hra-tracts-hu.html'))){
        show_hra_tr_pop() %>% 
        saveWidget(file = root_file('3-communication/others/html/hra-tracts-hu.html'),
                           selfcontained = FALSE,
                           libdir = root_file('3-communication/others/html/html_support_files'))
}

if(!file.exists(root_file('3-communication/others/html/hra-tracts-pophu.html'))){
        show_hra_tr_pop() %>% 
        saveWidget(file = root_file('3-communication/others/html/hra-tracts-pophu.html'),
                           selfcontained = FALSE,
                           libdir = root_file('3-communication/others/html/html_support_files'))
}


```


```{r hra-show-pop, fig.cap='HRA Census Tracts (by Population)'}
show_hra_tr_pop()

```

```{r hra-show-hu, fig.cap='HRA Census Tracts (by Housing Units)'}
show_hra_tr_hu()

```

```{r hra-show-pophu, fig.cap='HRA Census Tracts (by Population in Housing Units)'}
show_hra_tr_pophu()

```

































<!--chapter:end:hra-tracts.Rmd-->

---
always_allow_html: yes
df_print: tibble
output:
  html_notebook:
    code_folding: hide
  html_document: default
  pdf_document:
    keep_tex: yes
---

```{r kc-parcels-setup, echo = FALSE, warning=FALSE,message=FALSE}
library(knitr)
library(rprojroot)
library(tidyverse)
library(rgdal)
library(sp)
library(rgeos)
library(miscgis)
library(tigris)
library(leaflet)
library(ggthemes)
library(magrittr)
library(downloader)
root <- rprojroot::is_rstudio_project
root_file <- root$make_fix_file()
opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, comment = FALSE)
options("readr.num_columns" = 0)
```

### Introduction

Tax parcels are the pieces of land associated with property value. King County appraises parcels in order to determine an estimate of the fair market value, which is then used in the process of determening taxation amounts. For the purposes of this assessment, parcels are the geographic unit of the indicator of housing market conditions: residential property value. 

More information about the parcel dataset is available at the King County GIS Center:

  * [KCGIS Center](http://www.kingcounty.gov/operations/GIS/GISData.aspx)
  * [Parcel Shapefile Metadata](http://www5.kingcounty.gov/sdc/Metadata.aspx?Layer=parcel)

### Parcels in Seattle CCD

The entire dataset of King County parcels contains 602,803 records, which makes it challenging to work with because of the file size. The methodology of this project is to compare communities to the Seattle subdivision of King County, so the first step is to extract only the parcels in that geography.

The unique identifier for each parcel is called a `PIN`, and it is a combination of two numeric codes: a six-digit `MAJOR` (e.g., 092503) and a four-digit `MINOR` (e.g., 5891). After creating the `PIN` the `PropType` variable from the [KC assessor's parcel dataset](http://info.kingcounty.gov/Assessor/DataDownload/default.aspx) is joined to the spatial dataset from the KCGIS Center.

The spatial dataset's size is reduced by converting the polygon into points using the `rgeos::gCentroid()` function. `sp::over()` is then used to determine which parcels are overlayed by the Seattle CCD polygon (see this [excellent tutorial](https://cran.r-project.org/web/packages/sp/vignettes/over.pdf) for more details on `sp::over()`). The subset is exported, retaining its `SpatialPointsDataFrame` class.


```{r kc-parcels-main, echo = TRUE, eval=FALSE}
# Seattle subdivision of King County, WA (Seattle CCD)
sea_ccd <- readOGR(dsn = root_file('1-data/4-interim/seattle_ccd.gpkg'),layer = "seattle",verbose = FALSE) %>% spTransform(crs_proj)

# Parcels (tabular data only)
if(!file.exists(root_file('1-data/3-external/EXTR_Parcel.csv'))){
        url <- 'http://aqua.kingcounty.gov/extranet/assessor/Parcel.zip' # direct URL to the file download
        
        temp <- tempfile() # create a temporary file to hold the compressed download
        
        download(url, dest = temp, mode='wb') # download the file
        
        unzip (temp, exdir = root_file('1-data/3-external/')) # extract the file to the project folder
}

prcl_all_df <- 
        read_csv(root_file('1-data/3-external/EXTR_Parcel.csv'),progress = FALSE) %>% 
        mutate(PIN = paste0(Major,Minor)) %>% 
        select(PIN, PropType,CurrentZoning,CurrentUseDesignation)

colnames(prcl_all_df) %<>% toupper() 

# Parcels (sp): 2012

if(!file.exists(root_file('1-data/3-external/parcel/parcel.shp'))){
        url <- 'ftp://ftp.kingcounty.gov/gis-web/web/GISData/parcel_SHP.zip' # direct URL to the file download
        
        temp <- tempfile() # create a temporary file to hold the compressed download
        
        download(url, dest = temp, mode='wb') # download the file
        
        unzip (temp, exdir = root_file('1-data/3-external/')) # extract the file to the project folder
}

# Load the parcel file
# WARNING: large file with long load time

# Make the data
if(!file.exists(root_file('1-data/4-interim/prcl-ccd-ptdf-sp.gpkg'))){
        prcl_all_sp <- readOGR(dsn = root_file('1-data/3-external/parcel/'),layer = 'parcel',verbose = FALSE) 
        
        prcl_all_sp@data %<>% mutate(PIN = as.character(PIN))
        
        # prcl_all_sp %<>% spTransform(crs_proj)   # this reprojection is prohibively slow 
        
        join_df <- prcl_all_sp@data %>% as.data.frame() %>% left_join(.,prcl_all_df, by = "PIN")
        
        
        # Collect the centroids of all the KC parcels (and transform their CRS to match the project CRS)
        prcl_all_pt_sp <- prcl_all_sp %>% rgeos::gCentroid(byid = T) %>% spTransform(crs_proj)
        
        
        
        prcl_all_ptdf_sp <- SpatialPointsDataFrame(prcl_all_pt_sp,join_df,match.ID = FALSE)
        
        sea_ccd_poly <- SpatialPolygons(Srl = sea_ccd@polygons,proj4string = crs_proj) 
        
        # Using the sp::over 
        pts_over <- prcl_all_pt_sp %>% sp::over(sea_ccd_poly) 
        # prcl_ccd_sp <- prcl_all_sp[which(!is.na(pts_over)),] %>% spTransform(crs_proj) # slow
        prcl_ccd_pt_sp <- prcl_all_pt_sp[which(!is.na(pts_over)),]
        prcl_ccd_ptdf_sp <- prcl_all_ptdf_sp[which(!is.na(pts_over)),]
        
        prcl_ccd_ptdf_sp %>% 
                writeOGR(dsn = root_file('1-data/4-interim/prcl-ccd-ptdf-sp.gpkg'),
                         layer = 'prcl_ccd_ptdf_sp',driver = 'GPKG',
                         verbose = FALSE,
                         overwrite_layer = TRUE)
        
        
        rm(prcl_all_sp)
}

# Load the data
if(!exists('prcl_ccd_ptdf_sp')){
        prcl_ccd_ptdf_sp <- 
        readOGR(dsn = root_file('1-data/4-interim/prcl-ccd-ptdf-sp.gpkg'),
                layer = 'prcl_ccd_ptdf_sp',
                verbose = FALSE
        )
}


```

### Assigning Census Tracts to Parcels

The `sp::over()` function is used again, but this time to pass the unique identifier from the census tracts (`GEOID`) to each parcel that it overlay. This method resolves the issue of parcels that are overlayed by multiple tracts because it uses the centroid of the parcel instead of the polygon. Where the centroid is overlayed by two contiguous tract polygon boundaries only the first tract `GEOID` will be passed on.

```{r kc-parcels-to-tracts, echo = TRUE, eval=FALSE}

# Make the data
if(!file.exists(root_file('1-data/4-interim/prcl-ccd-tr-sp.gpkg'))){
        # Seattle CCD tracts
        if(!exists('tr_ccd_sp')){
                tr_ccd_sp <- readOGR(dsn = root_file('1-data/4-interim/tr-ccd-sp.gpkg'),
                                     layer = 'tr_ccd_sp',
                                     verbose = FALSE)
        }
        
        # Trim the data to just the GEOID variable
        tr_ccd_geoid_sp <- SpatialPolygonsDataFrame(tr_ccd_sp,tr_ccd_sp@data['GEOID']) %>% 
                spTransform(crs_proj)
        
        # Extract the census tract GEOID using a spatial overlay
        prcl_ccd_tr_sp <- SpatialPointsDataFrame(prcl_ccd_ptdf_sp@coords,
                                                 cbind(prcl_ccd_ptdf_sp@data,
                                                      sp::over(prcl_ccd_ptdf_sp,tr_ccd_geoid_sp)))
        prcl_ccd_tr_sp@data %<>% 
                mutate(GEOID = as.character(GEOID)) %>% 
                select(GEOID,everything())
        
        writeOGR(obj = prcl_ccd_tr_sp,
                 dsn = root_file('1-data/4-interim/prcl-ccd-tr-sp.gpkg'),
                 layer = 'prcl_ccd_tr_sp',
                 driver = 'GPKG',
                 verbose = FALSE,
                 overwrite_layer = TRUE)
}

# Load the data
if(!exists('prcl_ccd_tr_sp')){
        prcl_ccd_tr_sp <- 
                readOGR(dsn = root_file('1-data/4-interim/prcl-ccd-tr-sp.gpkg'),
                        layer = 'prcl_ccd_tr_sp',
                        verbose = FALSE)
}

```


<!--chapter:end:kc-parcels.Rmd-->

---
df_print: tibble
output:
  html_notebook:
    code_folding: hide
  pdf_document:
    keep_tex: yes
always_allow_html: yes
---

```{r misc-setup, echo = FALSE, warning=FALSE,message=FALSE,comment=FALSE}
library(knitr)
library(rprojroot)
library(tidyverse)
library(rgdal)
library(sp)
library(rgeos)
library(miscgis)
library(tigris)
library(leaflet)
library(ggthemes)
library(magrittr)
library(stringr)
library(downloader)
root <- rprojroot::is_rstudio_project
root_file <- root$make_fix_file()
opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, comment=FALSE)
```

###Seattle Boundary

```{r misc-sea-bound}

if(!file.exists(root_file('1-data/4-interim/seattle.gpkg'))){
        tigris::places(state = "WA") %>%
        tigris::filter_place(place = "Seattle") %>%
        spTransform(CRSobj = crs_proj) %>% 
        writeOGR(dsn = root_file('1-data/4-interim/seattle.gpkg'),
                 layer = "seattle", driver = "GPKG", verbose = FALSE, 
                 overwrite_layer = TRUE)
}

sea <- readOGR(dsn = root_file('1-data/4-interim/seattle.gpkg'),layer = "seattle",verbose = FALSE)

green <- miscgis::miscgis_pals$tableau_cat[["green"]]

myLfltGrey() %>% addPolygons(data = sea,color = green,opacity = 1,fillColor = green,fillOpacity = .5)

```

###King County Subdivision Boundary

```{r misc-sea-ccd}

if(!file.exists(root_file('1-data/4-interim/seattle_ccd.gpkg'))){
        tigris::county_subdivisions(state = "53",county = "033") %>% 
                subset(NAME == "Seattle") %>% 
                spTransform(CRSobj = crs_proj) %>% 
                writeOGR(dsn = root_file('1-data/4-interim/seattle_ccd.gpkg'),
                         layer = "seattle", driver = "GPKG", verbose = FALSE, 
                         overwrite_layer = TRUE)
}

sea_ccd <- readOGR(dsn = root_file('1-data/4-interim/seattle_ccd.gpkg'),layer = "seattle",verbose = FALSE) %>% spTransform(crs_proj)

orange <- miscgis::miscgis_pals$tableau_cat[["orange"]]

myLfltGrey() %>% addPolygons(data = sea_ccd,color = orange,opacity = 1,fillColor = orange,fillOpacity = .5)

```

### Tracts in Seattle CCD

In the absence of a straight-forward method for identifying all the census tracts in the Seattle CCD subdivision of King County, it is possible to extract this information from [American Factfinder](https://factfinder.census.gov/faces/nav/jsf/pages/index.xhtml). This [tutorial](https://ask.census.gov/faq.php?id=5000&faqId=1605) describes how to use the American Factfinder interface to extract a list of all "all tracts within (or partially within) a census place"; substituting "county subdivision" for "place" will retrieve the desired results.

```{r misc-tracts-ccd}


if(!file.exists(root_file('1-data/4-interim/tr-ccd-sp.gpkg'))){
        tr_ccd_geoid <- 
        read_csv(
                root_file('1-data/3-external/manual/seattle-ccd/ACS_12_5YR_B01001/ACS_12_5YR_B01001_with_ann.csv'), 
                col_types = cols(Id2 = col_character()), 
                skip = 1) %>% 
        mutate(NEW_GEOID1 = str_sub(Id2,1,5),
               NEW_GEOID2 = str_sub(Id2,16,21),
               GEOID = paste0(NEW_GEOID1,NEW_GEOID2)) %>% 
        select(GEOID) %>% unlist(use.names = F)
        
        # If the WA census tracts objects isn't yet loaded in the global env.,
        # download and load it
        if(!exists('tr')){tr <- tigris::tracts(state = "WA",county = "King", year = 2014) %>% spTransform(CRSobj = crs_proj)}
        
tr_ccd_sp <- subset(tr, GEOID %in% tr_ccd_geoid)

writeOGR(obj = tr_ccd_sp,
         dsn = root_file('1-data/4-interim/tr-ccd-sp.gpkg'),
         layer = 'tr_ccd_sp',
         driver = 'GPKG',
         verbose = FALSE,
         overwrite_layer = TRUE)
}

tr_ccd_sp <- readOGR(dsn = root_file('1-data/4-interim/tr-ccd-sp.gpkg'),
                     layer = 'tr_ccd_sp',
                     verbose = FALSE)
show_tr_ccd_sp <- function(){
        myLfltGrey() %>% 
        addPolygons(data = tr_ccd,weight = .5,color = blue,opacity = 1,fillColor = blue,fillOpacity = .5) %>% 
        addPolygons(data = sea_ccd,color = orange,opacity = 1,fillOpacity = 0)
}
# show_tr_ccd_sp()
```

###Puget Sound Waterbodies

These are useful for "clipping" census geographies whose boundaries extend into waterbodies.

```{r misc-wtr}

fp_wtr <- root_file('1-data/3-external/NHDMajor.gdb')

# check if the file already exists, if not then download it
if(!file.exists(fp_wtr)){
        
        url <- "ftp://www.ecy.wa.gov/gis_a/inlandWaters/NHD/NHDmajor.gdb.zip" # save the URL for the waterbodies data
        
        temp <- tempfile() # create a temporary file to hold the compressed download
        
        download(url, dest = temp, mode="wb") # download the file
        
        unzip (temp, exdir = root_file('1-data/3-external/')) # extract the ESRI geodatabase file to a project folder
}

wtr_sp <-
        suppressWarnings(readOGR(dsn = fp_wtr,      # create a waterbodies shape
                layer = "NHD_MajorWaterbodies",verbose = FALSE,pointDropZ = TRUE)) %>%
        gBuffer(byid=TRUE, width=0) %>% # clean up self-intersecting polygons
        spTransform(CRSobj = crs_proj)  # transform the projection to match the project projection
        

intersect <- gIntersects(sea_ccd,wtr_sp,byid = TRUE) %>% as.vector()

wtr_sp <- wtr_sp[intersect,] %>%
        spTransform(CRSobj = crs_proj)

blue <- miscgis::miscgis_pals$tableau_cat[["blue"]]

if(!file.exists(root_file('1-data/4-interim/wtr_sp.gpkg'))){
        writeOGR(obj = wtr_sp, dsn = root_file('1-data/4-interim/wtr_sp.gpkg'), 
          layer = "wtr_sp", driver = "GPKG", verbose = FALSE, 
          overwrite_layer = TRUE)
}

show_wtr <- function(){
        myLfltGrey() %>% 
                addPolygons(data = wtr_sp,color = blue, opacity = 1, 
                            weight = .5, fillColor = blue,fillOpacity = .5)        
}

show_wtr()

```

<!--chapter:end:misc.Rmd-->

---
title: "_Dataset_ | People of Color"
author: "Tiernan Martin, [Futurewise](http://www.futurewisewa.org/)"
output:
  html_notebook: default
  pdf_document: default
  word_document: default
subtitle: Communities of Opportunity Displacement Risk Assessment
df_print: tibble
---

###Introduction
This datset comes from the [American Community Survey](https://www.census.gov/programs-surveys/acs/). General information about the structure of this dataset can be found [here](https://factfinder.census.gov/faces/affhelp/jsf/pages/metadata.xhtml?lang=en&type=table&id=table.en.ACS_14_5YR_B03002#main_content).

This dataset is used to create the indicator "Percent People of Color", which is defined as the percentage of the population that is a race other than non-Hispanic White.

###Metadata

```{r, echo = FALSE, results="asis", warning=FALSE,message=FALSE}
library(knitr)
library(magrittr)
library(tidyverse)


df <- tibble(
        "Program" = "American Community Survey",
        "Data Set" = "2010-2014 American Community Survey 5-Year Estimates",
        "Table" = "B03002 - HISPANIC OR LATINO ORIGIN BY RACE"
           )


knitr::kable(df)

```

```{r, echo = FALSE, results= "asis",warning=FALSE,message=FALSE}
library(acs)
library(readr)


tbl <- "B03002"  # census table code
geog <- geo.make(state = "WA",county = "King",tract = "*")

#Coded column names
acs.fetch(endyear = "2014",
          span = 5,
          geography = geog,
          table.number = tbl,
          col.names = "pretty") %>% readr::write_rds("./1_raw/poc_pretty.rds")

# "Pretty" column names
acs.fetch(endyear = "2014",
          span = 5,
          geography = geog,
          table.number = tbl,
          col.names = "pretty") %>% readr::write_rds("./1_raw/poc_pretty.rds")

poc_acs <- read_rds("./1_raw/poc.rds")
poc_prty_acs <- read_rds("./1_raw/poc_pretty.rds")

knitr::kable(tibble("Abbr." = acs.colnames(poc_acs),
                    "Full Column Name" = acs.colnames(poc_prty_acs)),
             row.names = 1:ncol(poc_acs))
```


###Raw Data
The data is structured in a special format that retains important metadata about the variable, including the standard error values needed to calculate confidence intervals.
```{r,echo= FALSE}
head(poc_prty_acs[,1])
```




###New Column: People of Color
```{r}
poc_acs2 <- poc_acs[, "B03002_001"] - poc_acs[, "B03002_003"]
                                
acs.colnames(poc_acs2) <- "POC"

poc_acs2 %<>% cbind(poc_acs, .)

poc_acs3 <- 
        apply(
                X = poc_acs2[, 22],
                MARGIN = 1,
                FUN = divide.acs,
                denominator = poc_acs2[, 1],
                method = "proportion",
                verbose = FALSE
        )

acs.colnames(poc_acs3) <- "POC_PCT"

readr::write_rds(poc_acs3,"./2_intermediate/poc_acs.rds")

head(poc_acs3[])

```

###Conversion to a Dataframe

```{r}

poc_acs <- readr::read_rds("./2_intermediate/poc_acs.rds")

poc_df <- 
        data.frame(
                geography(poc_acs)["tract"], 
                estimate(poc_acs), 
                1.645 * standard.error(poc_acs)) %>% 
        `colnames<-`(., c("GEOID6", "POC_PCT_EST","POC_PCT_MOE")) %>% 
        mutate(UPPER = POC_PCT_EST + POC_PCT_MOE, 
               LOWER = POC_PCT_EST - POC_PCT_MOE, 
               UPPER = if_else(UPPER > 1, 1, UPPER), 
               LOWER = if_else(LOWER < 0, 0, LOWER))

readr::write_rds(poc_df,"./2_intermediate/poc_df.rds")
as_tibble(poc_df)

```

###Mapping

```{r, echo=FALSE,message=FALSE,fig.height=1.25, fig.width=1,  fig.show='hold', dpi=150,fig.cap='Rainier Valley, White Center, and SeaTac/Tukwila'}




```








<!--chapter:end:people_of_color.Rmd-->

---
df_print: tibble
output:
  html_notebook: default
  pdf_document:
    keep_tex: yes
always_allow_html: yes
---

```{r res-val-setup, echo = FALSE, warning=FALSE,message=FALSE}
library(knitr)
library(rprojroot)
library(tidyverse)
library(rgdal)
library(sp)
library(rgeos)
library(miscgis)
library(tigris)
library(leaflet)
library(ggthemes)
library(magrittr)
library(downloader)
root <- rprojroot::is_rstudio_project
root_file <- root$make_fix_file()
opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, comment = FALSE)
options("readr.num_columns" = 0)
```

### Introduduction

This dataset is a collection of property and building appraised values.

```{r res-val-dl, eval=FALSE}

if(!file.exists(root_file('1-data/3-external/EXTR_RealPropApplHist_V.csv'))){
        
        # direct URL to the file download
        url <- 'http://aqua.kingcounty.gov/extranet/assessor/Real%20Property%20Appraisal%20History.zip' 
        
        temp <- tempfile() # create a temporary file to hold the compressed download
        
        download(url, dest = temp, mode='wb') # download the file (~260MB)
        
        unzip (temp, exdir = root_file('1-data/3-external/')) # extract the file to the project folder
}

if(!exists('res_val_csv')){
        res_val_csv <- read_csv(
        root_file("1-data/3-external/EXTR_RealPropApplHist_V.csv"),
        col_types = cols(PostDate = col_datetime(format = "%Y-%m-%d %H:%M:%S"),
                         RollYr = col_date(format = "%Y"),
                         SelectDate = col_datetime(format = "%Y-%m-%d %H:%M:%S"),
                         UpdateDate = col_datetime(format = "%Y-%m-%d %H:%M:%S")),
        progress = FALSE)
}

# res_val_csv %>% head %>% as_tibble()

```

### Data Transformation
The following data transformations need to be completed in order to for this data to be useful for this project:

  * exclude parcels outside the Seattle CCD
  * exclude non-residential parcels
  * exclude years outside the observations periods (2005, 2010, and 2015)
  * exclude columns with information not relevant to this project (e.g., `SelectMethod`)
  * combine the values of the land and the structure(s) on the land (`LandVal` and `ImprsVal`, respectively)
  * adjust dollar amount for inflation based on 2016 US Dollar value
  * associate parcels with census tracts so that summary statistics can be calculated (e.g. median)


```{r res-val-rds, fig.cap='Parcel dataset attributes (5 randomly selected rows)'}

# Given the size of this dataset (~13M records, 1.8GB), it's useful to perform the simplest 
# filters first, then save and reload the reduced-size subset (~2M records, 89MB).

if(!file.exists(root_file('1-data/4-interim/res-val-sub1.Rds'))){
        
        res_val_orig <- res_val_csv
        
        colnames(res_val_orig) %<>% toupper()
        
        res_val_orig %>% 
        select(MAJOR:NEWDOLLARS,-REVALORMAINT) %>% 
        filter(ROLLYR %in% lubridate::as_date(c("2005-01-01","2010-01-01","2015-01-01"))) %>% 
        write_rds(root_file('1-data/4-interim/res-val-sub1.Rds'))
}

if(!exists('res_val_sub1')){res_val_sub1 <- read_rds(path = root_file('1-data/4-interim/res-val-sub1.Rds'))}

res_val_sub2 <- 
        res_val_sub1 %>% 
        mutate(PIN = paste0(MAJOR,MINOR)) %>% 
        select(PIN,everything())

set.seed(1)
res_val_sub2 %>% sample_n(5) %>% knitr::kable(caption = 'Parcel dataset attributes (5 randomly selected rows)',booktabs = TRUE)



```




<!--chapter:end:res-val.Rmd-->

---
title: "_Dataset_ | People of Color"
author: "Tiernan Martin, [Futurewise](http://www.futurewisewa.org/)"
output:
  html_notebook: default
  pdf_document: default
  word_document: default
subtitle: Communities of Opportunity Displacement Risk Assessment
df_print: tibble
---


### This is a test

And now you know!

<!--chapter:end:test.Rmd-->

---
df_print: tibble
output:
  html_notebook:
    code_folding: hide
  pdf_document:
    keep_tex: yes
always_allow_html: yes
---

```{r tracts-setup, echo = FALSE, warning=FALSE,message=FALSE,comment=FALSE}
library(knitr)
library(rprojroot)
library(tidyverse)
library(rgdal)
library(sp)
library(rgeos)
library(miscgis)
library(tigris)
library(leaflet)
library(ggthemes)
library(magrittr)
library(stringr)
library(downloader)
library(webshot)
library(htmltools)
library(gplots)
library(ggmap)
library(shiny)
library(htmlwidgets)
library(readxl)
root <- rprojroot::is_rstudio_project
root_file <- root$make_fix_file()
opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, comment=FALSE)
```



### Introduction
The primary geographic unit of this assessment is the [census tract](https://www.census.gov/geo/reference/gtc/gtc_ct.html). As is the case with many communities, the census geographies do not coincide exactly with the formal geographic boundary of the study's three sites, and should be considered as _spatial approximations_ of these communities.

Listed below are the geographic identifiers of the census tracts that approximate each site.


```{r tracts-intro, results="asis"}

# Rainier Valley
rv <- c("53033010001", "53033010300", "53033010401", "53033011001", "53033011002", "53033011101","53033011102", "53033011700", "53033011800", "53033011900")

# White Center
wc <- c("53033026600","53033026700","53033026500","53033026801","53033026802","53033027000")

# SeaTac/Tukwila

stc_hus <- read_csv(root_file('1-data/3-external/manual/seatac-tr/DEC_10_SF1_H1/DEC_10_SF1_H1_with_ann.csv'), 
                    col_types = cols(Id2 = col_character()), skip = 1)

tuk_hus <- read_csv(root_file('1-data/3-external/manual/tukwila-tr/DEC_10_SF1_H1/DEC_10_SF1_H1_with_ann.csv'), 
    col_types = cols(Id2 = col_character()), 
    skip = 1)

stc <-  paste(substr(x = stc_hus$Id2,1,2),substr(x = stc_hus$Id2,8,16),sep = "")

tuk <-  paste(substr(x = tuk_hus$Id2,1,2),substr(x = tuk_hus$Id2,8,16),sep = "")

stctuk <- c(stc,tuk)

df <- miscgis::cbind_fill(rv,wc,stctuk) %>% 
        as_tibble() %>% 
        `colnames<-`(c("Rainier Valley",
                       "White Center",
                       "SeaTac/Tukwila"))

knitr::kable(df,caption = "Census Tract GEOIDs")
```

### Spatial Polygons

#### With Waterbodies
Left to right: Rainier Valley, White Center, SeaTac/Tukwila
<br></br>

```{r tracts-with-wtr, fig.height=1.25, fig.width=1,  fig.show='hold', dpi=150,fig.cap='Rainier Valley, White Center, and SeaTac/Tukwila'}

# library(htmltools)
# library(htmlwidgets)
# library(leaflet)
# library(gplots)
# library(ggmap)
# library(rgeos)
# library(sp)
# library(magrittr)
# library(rgdal)

if(!file.exists(root_file('1-data/3-external/tr_kc.gpkg'))){
        tigris::tracts(state = "WA",county = "King", year = 2014) %>% 
        spTransform(CRSobj = crs_proj) %>% 
        writeOGR(dsn = root_file('1-data/3-external/tr_kc.gpkg'),
                 layer = 'tr_kc_sp',
                 driver = 'GPKG',
                 verbose = FALSE,  
                 overwrite_layer = TRUE)
}


tr <- readOGR(dsn = root_file('1-data/3-external/tr_kc.gpkg'),
              layer = 'tr_kc_sp',
              verbose = FALSE,
              stringsAsFactors = FALSE) %>% spTransform(crs_proj)

if(!file.exists(root_file("1-data/4-interim/tr_sp_withwater.gpkg"))){
        
tr_sel <- tr[tr$GEOID %in% c(rv,wc,stctuk),] %>% spTransform(CRSobj = crs_proj)

tr_sp <- tr_sel

tr_sp@data %<>% mutate(COO_SITE = case_when(.$GEOID %in% rv ~ "Rainier Valley",
                                            .$GEOID %in% wc ~ "White Center",
                                            .$GEOID %in% stctuk ~ "SeaTac/Tukwila"))
        
writeOGR(obj = tr_sp,
         dsn = root_file("1-data/4-interim/tr_sp_withwater.gpkg"),
         layer = "tr_sp_withwater",
         driver =  "GPKG",
         verbose = FALSE,
         overwrite_layer = TRUE)
}

tr_sp <- readOGR(dsn = root_file("1-data/4-interim/tr_sp_withwater.gpkg"),
         layer = "tr_sp_withwater",
         stringsAsFactors = FALSE,
         verbose = FALSE)


cntr <- tr_sp %>% gCentroid(byid = TRUE) %>% gCentroid()

blue <- miscgis::miscgis_pals$tableau_cat[["blue"]]
green <- miscgis::miscgis_pals$tableau_cat[["green"]]
red <- miscgis::miscgis_pals$tableau_cat[["red"]]
teal <- miscgis::miscgis_pals$tableau_cat[["teal"]]
brown <- miscgis::miscgis_pals$tableau_cat[["brown"]]


# Rainier Valley
        
rv_map <- miscgis::myLfltGrey() %>%
        addPolygons(data = tr_sp[tr_sp$COO_SITE == "Rainier Valley",],
                    smoothFactor = 0,
                    color = col2hex("white"),
                    weight = .5,
                    opacity = 1,
                    fillColor = blue,
                    fillOpacity = .65
        ) %>% 
        setView(cntr$x,cntr$y,zoom = 9) %>% 
        miscgis::styleWidget(style = "float:left;margin:1px")



# White Center


wc_map <- miscgis::myLfltGrey() %>%
        addPolygons(data = tr_sp[tr_sp$COO_SITE == "White Center",],
                    smoothFactor = 0,
                    color = col2hex("white"),
                    weight = .5,
                    opacity = 1,
                    fillColor = green,
                    fillOpacity = .65
        ) %>% 
        setView(cntr$x,cntr$y,zoom = 9) %>% 
        miscgis::styleWidget(style = "float:left;margin:1px")

# SeaTac/Tukwila

stctuk_map <- miscgis::myLfltGrey() %>%
        addPolygons(data = tr_sp[tr_sp$COO_SITE == "SeaTac/Tukwila",],
                    smoothFactor = 0,
                    color = col2hex("white"),
                    weight = .5,
                    opacity = 1,
                    fillColor = red,
                    fillOpacity = .65
        ) %>% 
        setView(cntr$x,cntr$y,zoom = 9) %>% 
        miscgis::styleWidget(style = "float:none;margin:1px")

rv_map
wc_map
stctuk_map


```


#### Without Waterbodies
Left to right: Rainier Valley, White Center, SeaTac/Tukwila
<br></br>

```{r tracts-wo-wtr, fig.height=1.25, fig.width=1,  fig.show='hold', dpi=150,fig.cap='Rainier Valley, White Center, and SeaTac/Tukwila'}


if(!file.exists(root_file('1-data/4-interim/tr_trim_sp.gpkg'))){
        
        wtr <- readOGR(dsn = root_file('1-data/4-interim/wtr_sp.gpkg'), 
          layer = "wtr_sp",verbose = FALSE) %>% gUnaryUnion(.) %>% spTransform(CRSobj = crs_proj)

spClip(tr_sp,wtr) %>% 
        subset(!duplicated(GEOID)) %>% 
        writeOGR(dsn = root_file('1-data/4-interim/tr_trim_sp.gpkg'),
         layer = "tr_trim_sp",driver = "GPKG",
         verbose = FALSE,
         overwrite_layer = TRUE)
}

tr_trim_sp <- readOGR(dsn = root_file('1-data/4-interim/tr_trim_sp.gpkg'),
         layer = "tr_trim_sp",
         verbose = FALSE,
         stringsAsFactors = FALSE)

# Individiaul Maps

rv_trim <- tr_trim_sp %>% subset(COO_SITE == "Rainier Valley")

wc_trim <- tr_trim_sp %>% subset(COO_SITE == "White Center")

stctuk_trim <- tr_trim_sp %>% subset(COO_SITE == "SeaTac/Tukwila")


# Rainier Valley
        
rv_trim_map <- miscgis::myLfltGrey() %>%
        addPolygons(data = rv_trim,
                    smoothFactor = 0,
                    color = col2hex("white"),
                    weight = .5,
                    opacity = 1,
                    fillColor = blue,
                    fillOpacity = .65
        ) %>% 
        setView(cntr$x,cntr$y,zoom = 9) %>% 
        miscgis::styleWidget(style = "float:left;margin:1px")



# White Center

wc_trim_map <- miscgis::myLfltGrey() %>%
        addPolygons(data = wc_trim,
                    smoothFactor = 0,
                    color = col2hex("white"),
                    weight = .5,
                    opacity = 1,
                    fillColor = green,
                    fillOpacity = .65
        ) %>% 
        setView(cntr$x,cntr$y,zoom = 9) %>% 
        miscgis::styleWidget(style = "float:left;margin:1px")

# SeaTac/Tukwila

stctuk_trim_map <- miscgis::myLfltGrey() %>%
        addPolygons(data = stctuk_trim,
                    smoothFactor = 0,
                    color = col2hex("white"),
                    weight = .5,
                    opacity = 1,
                    fillColor = red,
                    fillOpacity = .65
        ) %>% 
        setView(cntr$x,cntr$y,zoom = 9) %>% 
        miscgis::styleWidget(style = "float:none;margin:1px")

rv_trim_map

wc_trim_map

stctuk_trim_map



```


#### Health Reporting Areas (Disaggregated by Tract)
```{r tracts-combined, dpi = 150}
# Combined map 

# if(!exists('tr')){
#         tr <- readOGR(dsn = root_file('1-data/3-external/tr_kc.gpkg'),
#               layer = 'tr_kc_sp',
#               verbose = FALSE,
#               stringsAsFactors = FALSE) %>% spTransform(crs_proj)
# }
# 
# pts <- gCentroid(tr,byid = TRUE) %>% spTransform(crs_proj) %>% 
#         SpatialPointsDataFrame(data = tr@data,match.ID = FALSE)
# 
# if(!exists('tr_trim_sp')){
# tr_trim_sp <- readOGR(dsn = root_file('1-data/4-interim/tr_trim_sp.gpkg'),layer = 'tr_trim_sp',verbose = FALSE,stringsAsFactors = FALSE)
# }
# 
# popups <- paste0(tr_trim_sp@data$GEOID)
# 
# hra <- readOGR(dsn = root_file('1-data/3-external/manual/HRA_2010Block_Clip/'),
#                layer = "HRA_2010Block_Clip",stringsAsFactors = FALSE,verbose = FALSE) %>% spTransform(crs_proj)
# 
# rv_hra_id <- c("SE Seattle",
#                "Beacon/Gtown/S.Park")
# 
# wc_hra_id <- c("North Highline")
# 
# stctuk_hra_id <- c("SeaTac/Tukwila")
# 
# 
# hra@data %<>% mutate(HRA_ID = case_when(.$HRA2010v2_ %in% rv_hra_id ~ "Rainier Valley",
#                                         .$HRA2010v2_ %in% wc_hra_id ~ "White Center",
#                                         .$HRA2010v2_ %in% stctuk_hra_id ~ "SeaTac/Tukwila"),
#                      HRA_ID_FCT = factor(HRA_ID,
#                                    levels = c("Rainier Valley",
#                                 "White Center",
#                                 "SeaTac/Tukwila"),ordered = TRUE)
#                      )
# 
# hra_coo <- hra %>% subset(!is.na(HRA_ID))
# 
# popup_hra <- paste0(hra_coo$HRA2010v2_)
# 
# # rv_tr_hra <- c(53033010100,53033010300,53033010200,53033011102,53033011101,53033011800,53033011900,53033026001) %>% as.character()
# # 
# # wc_tr_hra <- c(53033009300,53033010002,53033010001,53033010402,53033010401,53033011002,53033011001,53033010900,53033011200,53033011700,53033026400,53033026500,53033026600,53033026700,53033027000,53033026802,53033026801) %>% as.character()
# # 
# # stctuk_tr_hra <- c(53033026300,53033026400,53033027200,53033027100,53033026200,53033028200,53033028100,53033027300,53033028000,53033028500,53033028402,53033028300,53033028403,53033028802,53033028700,53033028801,53033028500,53033029101) %>% 
# #         as.character()
# 
# site_hra_tr <- read_excel(root_file('/1-data/3-external/manual/Definition_GeographicUnit_COO_20160913-tm-edit.xlsx'), 
#                           col_types = c("text", "text", "numeric", "text", "text", "text", "text"))
# colnames(site_hra_tr) %<>% toupper()
# 
# site_hra_tr %<>% 
#         select(GEOID,SITES) %>% 
#         mutate(SITES2 = SITES) %>% 
#         group_by(GEOID) %>% 
#         mutate(SITES2 = nth(SITES,2),
#                SITES2 = ifelse(SITES == SITES2,NA_character_,SITES2)) %>% 
#         transmute(SITES = ifelse(is.na(SITES2),SITES,paste(SITES,SITES2,sep = ":")),
#                   SITES_FCT = factor(SITES,
#                      levels = c("Rainier Valley",
#                                 "Rainier Valley:SeaTac/Tukwila",
#                                 "White Center",
#                                 "White Center:SeaTac/Tukwila",
#                                 "SeaTac/Tukwila"),ordered = TRUE))
# 
# 
# site_names <- site_hra_tr$SITES_FCT %>% levels() %>% as.character()
# 
# hra_geoids_lst <- split(site_hra_tr, site_hra_tr$SITES_FCT) %>% 
#         map(.f = ~.['GEOID']) %>% flatten() %>% 
#         `names<-`(site_names)
# 
# tr_trim_sp@data %<>% mutate(HRA_COO_SITE = case_when(
#         .$GEOID %in% unlist(hra_geoids_lst["Rainier Valley"], use.names = FALSE) ~ "Rainier Valley",
#         .$GEOID %in% unlist(hra_geoids_lst["Rainier Valley:SeaTac/Tukwila"], use.names = FALSE) ~ "Rainier Valley:SeaTac/Tukwila",
#         .$GEOID %in% unlist(hra_geoids_lst["White Center"], use.names = FALSE) ~ "White Center",
#         .$GEOID %in% unlist(hra_geoids_lst["White Center:SeaTac/Tukwila"], use.names = FALSE) ~ "White Center:SeaTac/Tukwila",
#         .$GEOID %in% unlist(hra_geoids_lst["SeaTac/Tukwila"], use.names = FALSE) ~ "SeaTac/Tukwila"),
#         HRA_COO_SITE_FCT = factor(HRA_COO_SITE,
#                      levels = c("Rainier Valley",
#                                 "Rainier Valley:SeaTac/Tukwila",
#                                 "White Center",
#                                 "White Center:SeaTac/Tukwila",
#                                 "SeaTac/Tukwila"),ordered = TRUE)
#                             )
# 
# tr_hra <- tr
# 
# tr_hra@data %<>% mutate(HRA_COO_SITE = case_when(
#         .$GEOID %in% unlist(hra_geoids_lst["Rainier Valley"], use.names = FALSE) ~ "Rainier Valley",
#         .$GEOID %in% unlist(hra_geoids_lst["Rainier Valley:SeaTac/Tukwila"], use.names = FALSE) ~ "Rainier Valley:SeaTac/Tukwila",
#         .$GEOID %in% unlist(hra_geoids_lst["White Center"], use.names = FALSE) ~ "White Center",
#         .$GEOID %in% unlist(hra_geoids_lst["White Center:SeaTac/Tukwila"], use.names = FALSE) ~ "White Center:SeaTac/Tukwila",
#         .$GEOID %in% unlist(hra_geoids_lst["SeaTac/Tukwila"], use.names = FALSE) ~ "SeaTac/Tukwila"),
#         HRA_COO_SITE_FCT = factor(HRA_COO_SITE,
#                      levels = c("Rainier Valley",
#                                 "Rainier Valley:SeaTac/Tukwila",
#                                 "White Center",
#                                 "White Center:SeaTac/Tukwila",
#                                 "SeaTac/Tukwila"),ordered = TRUE)
#                             )
# 
# if(!exists('wtr_sp')){
# wtr_sp <- readOGR(dsn = root_file('1-data/4-interim/wtr_sp.gpkg'),layer = 'wtr_sp',verbose = FALSE,stringsAsFactors = FALSE) %>% spTransform(crs_proj)
# }
# 
# tr_hra %<>% subset(!is.na(HRA_COO_SITE)) %>% spClip(wtr_sp)
# 
# # Color palettes
# 
# pal_rgb_3 <- miscgis_pals$tableau_cat[c("blue","green","red")] %>% unlist %>% palette()
# pal_rgb_5 <- miscgis_pals$tableau_cat[c("blue","teal","green","brown","red")] %>% unlist %>% palette()
# 
# pal_3 <- colorFactor(pal_rgb_3,
#                    domain = factor(tr_trim_sp$COO_SITE,
#                                    levels = c("Rainier Valley",
#                                 "White Center",
#                                 "SeaTac/Tukwila"),ordered = TRUE))
# pal_5 <- colorFactor(pal_rgb_5,domain = tr_hra$HRA_COO_SITE_FCT)
# 
# 
# if(!file.exists(root_file('3-commmunication/others/html/tr_coo_sites.html'))){
#         leaflet() %>%
#                 addProviderTiles(providers$CartoDB.Positron) %>% 
#                 addPolygons(data = tr_trim_sp,
#                             smoothFactor = 0,
#                             color = col2hex("white"),
#                             weight = .5,
#                             opacity = 1,
#                             fillColor = ~pal_3(COO_SITE),
#                             fillOpacity = .65,
#                             group = "COO Sites - Guess") %>% 
#                 addPolygons(data = hra_coo,
#                             smoothFactor = 0,
#                             color = ~pal_3(HRA_ID_FCT),
#                             weight = 2.5,
#                             opacity = 1,
#                             fillOpacity = 0,
#                             popup = popup_hra,
#                             group = "HRA Boundaries") %>% 
#                 addPolygons(data = tr_hra,
#                             smoothFactor = 0,
#                             color = col2hex("white"),
#                             weight = .5,
#                             opacity = 1,
#                             fillColor = ~pal_5(HRA_COO_SITE_FCT),
#                             fillOpacity = .65,
#                             group = "COO Sites - HRA") %>%
#                 addPolygons(data = tr,
#                             smoothFactor = 0,
#                             weight = .75,
#                             color = col2hex("grey50"),
#                             opacity = .75,
#                             fillOpacity = 0,
#                             group = "All Tracts", popup = popups) %>%
#                 # addPolygons(data = hra,
#                 #             smoothFactor = 0,
#                 #             color = col2hex("white"),
#                 #             weight = .5,
#                 #             opacity = 1,
#                 #             fillColor = ~pal(COO_SITE),
#                 #             fillOpacity = .65,
#                 #             group = "HRA") %>% 
#                 setView(cntr$x,cntr$y,zoom = 11) %>% 
#                 addLayersControl(overlayGroups = c("COO Sites - HRA",
#                                                    "COO Sites - Guess",
#                                                    "HRA Boundaries",
#                                                    "All Tracts")) %>% 
#                 addLegend(title = "COO Sites",
#                           position = "topright",
#                           pal = pal_5,
#                           values = tr_trim_sp$HRA_COO_SITE_FCT) %>% 
#                 saveWidget(file = root_file('3-communication/others/html/tr_coo_sites.html'),
#                            selfcontained = FALSE,
#                            libdir = root_file('3-communication/others/html/html_support_files'))
# }

```


<!--chapter:end:tracts.Rmd-->

